[{"kind":1,"language":"markdown","value":"## SQL Data Access","outputs":[]},{"kind":1,"language":"markdown","value":"The PROC SQL equivalent of a PROC IMPORT step doesn't exist in Base SAS, because PROC SQL cannot directly read external CSV files.","outputs":[]},{"kind":1,"language":"markdown","value":"## SQL Data Exploration","outputs":[]},{"kind":1,"language":"markdown","value":"Programming in SAS is largely procedural with a step-by-step data flow, PROC SQL offers a declarative, SQL-based approach for working with structured data, while Python is fully object-oriented, enabling greater flexibility, modularity, and integration with diverse libraries for data manipulation and analysis.","outputs":[]},{"kind":1,"language":"markdown","value":"Obtain metadata info by mimicking PROC CONTENTS using PROC SQL","outputs":[]},{"kind":2,"language":"sas","value":"proc sql;\n    describe table dictionary.columns;","outputs":[]},{"kind":2,"language":"sas","value":"proc sql;\n    select memname, name, type, length from dictionary.columns\n    where libname=\"WORK\" and upcase(memname)=\"DST2\"","outputs":[]},{"kind":1,"language":"markdown","value":"The powerful ability of SQL to explore Metadata is examined in the code below. Locate common columns in all tables by sweeping the WORK library ","outputs":[]},{"kind":2,"language":"sas","value":"proc sql;\n    select memname, name, type, length\n    from dictionary.columns\n    where libname=\"WORK\"\n    group by name\n    having count(name) > 1\n    order by 2;\nquit;","outputs":[]},{"kind":1,"language":"markdown","value":"PROC SQL to print","outputs":[]},{"kind":2,"language":"sas","value":"proc sql outobs=5;\n    select *\n    from dst2;\nquit;","outputs":[]},{"kind":1,"language":"markdown","value":"Breakdown : The OUTOBS= option restricts the number of rows that PROC SQL displays or writes to a table. For example, if you specify OUTOBS=10 and insert values into a table by using a query, then PROC SQL inserts a maximum of 10 rows into the resulting table. OUTOBS= is similar to the SAS data set option OBS=.","outputs":[]},{"kind":1,"language":"markdown","value":"In PROC SQL, mean, min, max, std, and count replicate the default statistics from PROC MEANS.","outputs":[]},{"kind":2,"language":"sas","value":"title \"Analysis Variable : year\";\nproc sql;\n    select \n        count(year) as N,\n        mean(year) as Mean,\n         std(year) as StdDev,\n         min(year) as Minimum,\n        max(year) as Maximum        \n    from dst2;\nquit;","outputs":[]},{"kind":1,"language":"markdown","value":"PROC FREQ In SQL","outputs":[]},{"kind":2,"language":"sas","value":"/*Step 1: Get frequency and percent using PROC SQL*/\nproc sql;\n    create table freq_state as\n    select \n        stateProvince,\n        count(*) as Frequency,\n        calculated Frequency / total_count * 100 as Percent format=6.2\n    from \n        (select * from dst2),\n        (select count(*) as total_count from dst2)\n    group by stateProvince\n    order by Frequency desc;\nquit;","outputs":[]},{"kind":1,"language":"markdown","value":"Breakdown: This PROC SQL code creates a summary table showing the frequency and percent of each stateProvince value in dst2, by grouping the data and dividing each count by the total number of rows to mimic PROC FREQ output.","outputs":[]},{"kind":2,"language":"sas","value":"/*Step 2: Add cumulative frequency and percent using a DATA step*/\ndata freq_state_final;\n    set freq_state;\n    retain CumFreq CumPercent 0;\n    CumFreq + Frequency;\n    CumPercent + Percent;\nrun;","outputs":[]},{"kind":1,"language":"markdown","value":"Breakdown : The above DATA step adds cumulative frequency and cumulative percent to each row in freq_state by retaining running totals across observations.","outputs":[]},{"kind":2,"language":"sas","value":"/*Step 3: Print the resulting dataset*/\nproc sql;\n    select * from freq_state_final;\nquit;","outputs":[]},{"kind":1,"language":"markdown","value":"## SQL Data Preparation","outputs":[]},{"kind":1,"language":"markdown","value":"Concatenation","outputs":[]},{"kind":2,"language":"sas","value":"proc sql;\n    create table dsconc as\n    select * from dst1 where country <> 'Alaska'\n    union corr\n    select * from dst2;\nquit;","outputs":[]},{"kind":1,"language":"markdown","value":"What is the difference between Data step & SQL during concatenation?","outputs":[]},{"kind":1,"language":"markdown","value":"Joining","outputs":[]},{"kind":2,"language":"sas","value":"proc sql;\n    create table dsmerge as\n    select *\n    from dsconc as a\n    inner join dst3 as b\n    on a.scientificName = b.scientificName;\nquit;","outputs":[]},{"kind":1,"language":"markdown","value":"The merge ... by ... if inc and ind; logic keeps only matching records from both datasets, which is exactly what an INNER JOIN does.\n\nAliases a and b allow you to reference columns uniquely if needed.","outputs":[]},{"kind":1,"language":"markdown","value":"## SQL Data Analysis","outputs":[]},{"kind":2,"language":"sas","value":"proc sql outobs=10;\n    select *\n    from dst3\n    where prxmatch('/(ed|ern)(\\s|-)|\\-/i', commonname);\nquit;","outputs":[]},{"kind":1,"language":"markdown","value":"Breakdown \nprxmatch('/(ed|ern)(\\s|-)|\\-/i', commonname) applies the same regex filter.","outputs":[]},{"kind":1,"language":"markdown","value":"### Grouping Aggregate Data","outputs":[]},{"kind":2,"language":"sas","value":"title \"Count of Bees by Scientific Name and StateProvince\";\nproc sql;\nselect  scientificname, stateprovince,  count(scientificname) as count 'Number of Bees'\nfrom dst1\ngroup by 2,  1\norder by 3 desc,2, 1\n;","outputs":[]},{"kind":1,"language":"markdown","value":"## SQL Data Reporting","outputs":[]},{"kind":1,"language":"markdown","value":"The PROC SQL step is for querying and manipulating data â€” not for creating plots or layouts, so the SGPLOT and ODS LAYOUT steps cannot be converted into PROC SQL.","outputs":[]}]